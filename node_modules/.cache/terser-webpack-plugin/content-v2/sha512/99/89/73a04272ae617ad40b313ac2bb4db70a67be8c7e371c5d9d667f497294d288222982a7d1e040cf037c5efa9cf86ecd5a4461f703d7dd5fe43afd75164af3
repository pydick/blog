{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{356:function(e,s,a){\"use strict\";a.r(s);var t=a(42),r=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h2\",{attrs:{id:\"归纳点-待细化分化\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#归纳点-待细化分化\"}},[e._v(\"#\")]),e._v(\" 归纳点(待细化分化)\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"props-与-ref-实例区别\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#props-与-ref-实例区别\"}},[e._v(\"#\")]),e._v(\" props 与 ref 实例区别\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"prop 着重于数据的传递，它并不能调用子组件里的属性(属性赋值给父组件)和方法。像创建文章组件时，自定义标题和内容这样的使用场景，最适合使用prop。\")]),e._v(\" \"),a(\"li\",[e._v(\"$ref 着重于索引，主要用来调用子组件里的属性(属性赋值给父组件)和方法，其实并不擅长数据传递。而且ref用在dom元素的时候，能使到选择器的作用，这个功能比作为索引更常有用到。\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"匿名插槽、具名插槽与作用域插槽-数据显示上区别-复合组件使用\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#匿名插槽、具名插槽与作用域插槽-数据显示上区别-复合组件使用\"}},[e._v(\"#\")]),e._v(\" 匿名插槽、具名插槽与作用域插槽 数据显示上区别(复合组件使用)\")]),e._v(\" \"),a(\"p\",[e._v(\"匿名插槽、具名插槽=>数据由父组件控。 作用域插槽=> 数据由子组件控制\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"递归组件-name-作用\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#递归组件-name-作用\"}},[e._v(\"#\")]),e._v(\" 递归组件 name 作用\")]),e._v(\" \"),a(\"p\",[e._v(\"自生调用自己 需要使用name\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"provide-inject-传值应用场景\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#provide-inject-传值应用场景\"}},[e._v(\"#\")]),e._v(\" provide/inject 传值应用场景\")]),e._v(\" \"),a(\"p\",[e._v(\"用于组件库封装\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"vue-extend-与-new-vue\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-extend-与-new-vue\"}},[e._v(\"#\")]),e._v(\" Vue.extend 与 new Vue\")]),e._v(\" \"),a(\"p\",[e._v(\"vue.extend() 是new vue() 的一个子类。用法都一样，都是实例化一个对象，然后是挂载到到dom元素上。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"vue-插件-与-vue-组件区别\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-插件-与-vue-组件区别\"}},[e._v(\"#\")]),e._v(\" Vue 插件 与 vue 组件区别\")]),e._v(\" \"),a(\"p\",[e._v(\"Vue 插件 和 Vue组件 只是在 Vue.js 中包装的两个概念而已​，不管是插件还是组件，最终目的都是为了实现逻辑复用。它们的本质都是对代码逻辑的封装，只是封装方式不同而已。在必要时，组件也可以封装成插件，插件也可以改写成组件，就看实际哪种封装更方便使用了。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"load-事件-与-hashchange-事件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#load-事件-与-hashchange-事件\"}},[e._v(\"#\")]),e._v(\" load 事件 与 hashchange 事件\")]),e._v(\" \"),a(\"p\",[e._v(\"load=>页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件。hashchange=>当URL的片段标识符更改时，将触发hashchange事件 (跟在＃符号后面的URL部分，包括＃符号)\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"bind\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#bind\"}},[e._v(\"#\")]),e._v(\" bind\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[e._v(\"call&appy => call和apply改变了函数的this上下文后便执行该函数。bind => 则是返回改变了上下文后的一个函数，用于监听回调后执行。\")]),e._v(\" \"),a(\"li\",[e._v(\"call与appy 只是传参数区别，es6存在扩展运算之后，基本随意使用，习惯用appy\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"vue-插件作用\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-插件作用\"}},[e._v(\"#\")]),e._v(\" vue 插件作用\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- line-numbers-mode\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"MyPlugin.install = function (Vue, options) {\\n  // 1. 添加全局方法或 property\\n  Vue.myGlobalMethod = function () {\\n    // 逻辑...\\n  }\\n\\n  // 2. 添加全局资源\\n  Vue.directive('my-directive', {\\n    bind (el, binding, vnode, oldVnode) {\\n      // 逻辑...\\n    }\\n    ...\\n  })\\n\\n  // 3. 注入组件选项\\n  Vue.mixin({\\n    created: function () {\\n      // 逻辑...\\n    }\\n    ...\\n  })\\n\\n  // 4. 添加实例方法\\n  Vue.prototype.$myMethod = function (methodOptions) {\\n    // 逻辑...\\n  }\\n}\\n\")])]),e._v(\" \"),a(\"div\",{staticClass:\"line-numbers-wrapper\"},[a(\"span\",{staticClass:\"line-number\"},[e._v(\"1\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"2\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"3\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"4\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"5\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"6\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"7\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"8\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"9\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"10\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"11\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"12\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"13\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"14\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"15\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"16\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"17\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"18\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"19\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"20\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"21\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"22\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"23\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"24\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"25\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"26\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[e._v(\"27\")]),a(\"br\")])]),a(\"h3\",{attrs:{id:\"es6-proxy\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es6-proxy\"}},[e._v(\"#\")]),e._v(\" es6 proxy\")]),e._v(\" \"),a(\"p\",[e._v(\"用proxy实例对象去代理，拦截，操作源对象，让源对象不暴露\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"es5的object-defineproperty\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es5的object-defineproperty\"}},[e._v(\"#\")]),e._v(\" es5的Object.defineProperty\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"ol\",[a(\"li\",[e._v(\"为对象定义一个属性,或是修改已有属性的值，并设置该属性的描述符。该方法返回修改后的对象。\")])])]),e._v(\" \"),a(\"li\",[a(\"ol\",{attrs:{start:\"2\"}},[a(\"li\",[e._v(\"getter(get:它是一个函数，访问该属性时会自动调用，函数的返回值即为该属性的value。默认为undefined。)与setter(set：它是一个函数，为该属性赋值时会自动调用，并且新值会被当做参数传入。), 为属性赋值的时候会自动执行一个函数，就能监控到数据的变化，从而实现mvvm的双向绑定。\")])])]),e._v(\" \"),a(\"li\",[a(\"ol\",{attrs:{start:\"3\"}},[a(\"li\",[e._v(\"写一个公共模块，会往window上挂一些全局属性，并且你不希望别人在其他地方不小心覆盖这个属性，那就可以用defineProperty让该属性不可写、不可配置\")])])])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"es5的object-defineproperty-vs-es6的proxy\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es5的object-defineproperty-vs-es6的proxy\"}},[e._v(\"#\")]),e._v(\" es5的Object.defineProperty() VS es6的Proxy\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；\")]),e._v(\" \"),a(\"li\",[e._v(\"Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。\")]),e._v(\" \"),a(\"li\",[e._v(\"Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。\")]),e._v(\" \"),a(\"li\",[e._v(\"Proxy 兼容性差\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"强缓存与协商缓存-缓存存的是静态资源\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#强缓存与协商缓存-缓存存的是静态资源\"}},[e._v(\"#\")]),e._v(\" 强缓存与协商缓存(缓存存的是静态资源))\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[a(\"p\",[e._v(\"缓存的http原理(流程解释)：二次请求资源时，首先判断是否过期(新鲜度),\"),a(\"br\"),e._v(\"\\n1.1 没过期，从缓存中读取缓存(该缓存叫做强缓存)\"),a(\"br\"),e._v(\"\\n1.2 过期了，发送请求到服务器验证，\"),a(\"br\"),e._v(\"\\n1.2.1 资源对比，无修改过，读取缓存(该缓存叫做协商缓存)，更新缓存的属性信息\"),a(\"br\"),e._v(\"\\n1.2.2 资源对比，有修改过，\"),a(\"br\"),e._v(\"\\n1.2.3 请求成功拿到结果覆盖缓存\\n1.2.4 请求失败未获取结果，返回404，删除缓存\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"不管是强缓存，还是协商缓存，都只有是get请求\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"强缓存状态码---200 (from cache) 协商缓存状态码---304 (not modified)\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"关于静态资源问题，一般改动不大的静态资源用cdn服务器上(如：bootsrap.min.js)，关于和业务相关的静态资源用业务服务器(即线上该产品的服务器)\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"关于从浏览器内存拿缓存问题，这个不重要，重要再说\")])])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"深拷贝与浅拷贝\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#深拷贝与浅拷贝\"}},[e._v(\"#\")]),e._v(\" 深拷贝与浅拷贝\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"浅拷贝=>是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。深拷贝=>是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。\")]),e._v(\" \"),a(\"li\",[e._v(\"深拷贝方式: 1、Object.assign() 2、展开运算符... 3、JSON.parse(JSON.stringify()) 4、其他比如 函数库lodash的_.clone/或则递归手写\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"promise\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#promise\"}},[e._v(\"#\")]),e._v(\" promise\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"promise 是构造函数，原型链上then,catch方法，用来解决回调地狱，根据单向不可逆状态的改变，在promise构造函数的参数回调函数处理执行异步操作，把异步操作的结果then和catch中处理\")]),e._v(\" \"),a(\"li\",[e._v(\"promise catch 优先 then的error回调，因为在then的success回调有错误，catch能继续执行，并把错误传到catch,不会终止运行，提高容错率，相当于try catch\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"var-let-const-区别\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#var-let-const-区别\"}},[e._v(\"#\")]),e._v(\" var，let,const 区别\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"假设es5有块级作用域的概念，if和for的作用域相当于块级作用域， var 可以跨块级作用域访问(因为变量提升)，let ，const 不能跨块级作用作用域访问\")]),e._v(\" \"),a(\"li\",[e._v(\"都不能跨函数作用域访问\")]),e._v(\" \"),a(\"li\",[e._v(\"var let 可以修改 const 不能修改\")]),e._v(\" \"),a(\"li\",[e._v(\"var let 可以不初始化  而const 必须初始化\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"请求响应时间长\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#请求响应时间长\"}},[e._v(\"#\")]),e._v(\" 请求响应时间长\")]),e._v(\" \"),a(\"ol\",[a(\"li\",[e._v(\"前端只能给优化方案，请求分批请求再合并数据，给菊花图\")]),e._v(\" \"),a(\"li\",[e._v(\"设置状态，一个查询状态请求，一个拿数据请求，然后去轮询/递归\")]),e._v(\" \"),a(\"li\",[e._v(\"前端做一个缓存机制，取到前一次数据缓存，避免同一个下次请求\")]),e._v(\" \"),a(\"li\",[e._v(\"再不行，怼后端去\")])])])}),[],!1,null,null,null);s.default=r.exports}}]);","extractedComments":[]}