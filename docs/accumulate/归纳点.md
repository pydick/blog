## 归纳点(待细化分化)
### props 与 ref 实例区别
* prop 着重于数据的传递，它并不能调用子组件里的属性(属性赋值给父组件)和方法。像创建文章组件时，自定义标题和内容这样的使用场景，最适合使用prop。
* $ref 着重于索引，主要用来调用子组件里的属性(属性赋值给父组件)和方法，其实并不擅长数据传递。而且ref用在dom元素的时候，能使到选择器的作用，这个功能比作为索引更常有用到。

### 匿名插槽、具名插槽与作用域插槽 数据显示上区别(复合组件使用)
匿名插槽、具名插槽=>数据由父组件控。 作用域插槽=> 数据由子组件控制
### 递归组件 name 作用
自生调用自己 需要使用name

### provide/inject 传值应用场景
用于组件库封装

### Vue.extend 与 new Vue 
vue.extend() 是new vue() 的一个子类。用法都一样，都是实例化一个对象，然后是挂载到到dom元素上。

### Vue 插件 与 vue 组件区别

Vue 插件 和 Vue组件 只是在 Vue.js 中包装的两个概念而已​，不管是插件还是组件，最终目的都是为了实现逻辑复用。它们的本质都是对代码逻辑的封装，只是封装方式不同而已。在必要时，组件也可以封装成插件，插件也可以改写成组件，就看实际哪种封装更方便使用了。

### load 事件 与 hashchange 事件
load=>页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件。hashchange=>当URL的片段标识符更改时，将触发hashchange事件 (跟在＃符号后面的URL部分，包括＃符号)

### bind

* call&appy => call和apply改变了函数的this上下文后便执行该函数。bind => 则是返回改变了上下文后的一个函数，用于监听回调后执行。
* call与appy 只是传参数区别，es6存在扩展运算之后，基本随意使用，习惯用appy

### vue 插件作用
```js
MyPlugin.install = function (Vue, options) {
  // 1. 添加全局方法或 property
  Vue.myGlobalMethod = function () {
    // 逻辑...
  }

  // 2. 添加全局资源
  Vue.directive('my-directive', {
    bind (el, binding, vnode, oldVnode) {
      // 逻辑...
    }
    ...
  })

  // 3. 注入组件选项
  Vue.mixin({
    created: function () {
      // 逻辑...
    }
    ...
  })

  // 4. 添加实例方法
  Vue.prototype.$myMethod = function (methodOptions) {
    // 逻辑...
  }
}
```
### es6 proxy
用proxy实例对象去代理，拦截，操作源对象，让源对象不暴露

### es5的Object.defineProperty
* 1. 为对象定义一个属性,或是修改已有属性的值，并设置该属性的描述符。该方法返回修改后的对象。
* 2. getter(get:它是一个函数，访问该属性时会自动调用，函数的返回值即为该属性的value。默认为undefined。)与setter(set：它是一个函数，为该属性赋值时会自动调用，并且新值会被当做参数传入。), 为属性赋值的时候会自动执行一个函数，就能监控到数据的变化，从而实现mvvm的双向绑定。
* 3. 写一个公共模块，会往window上挂一些全局属性，并且你不希望别人在其他地方不小心覆盖这个属性，那就可以用defineProperty让该属性不可写、不可配置


### es5的Object.defineProperty() VS es6的Proxy

1. Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
2. Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。
3. Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。
3. Proxy 兼容性差

### 强缓存与协商缓存(缓存存的是静态资源))
1. 缓存的http原理(流程解释)：二次请求资源时，首先判断是否过期(新鲜度),    
   1.1 没过期，从缓存中读取缓存(该缓存叫做强缓存)  
   1.2 过期了，发送请求到服务器验证，  
       1.2.1 资源对比，无修改过，读取缓存(该缓存叫做协商缓存)，更新缓存的属性信息  
       1.2.2 资源对比，有修改过，  
       1.2.3 请求成功拿到结果覆盖缓存 
       1.2.4 请求失败未获取结果，返回404，删除缓存  

2. 不管是强缓存，还是协商缓存，都只有是get请求  
3. 强缓存状态码---200 (from cache) 协商缓存状态码---304 (not modified)  
4. 关于静态资源问题，一般改动不大的静态资源用cdn服务器上(如：bootsrap.min.js)，关于和业务相关的静态资源用业务服务器(即线上该产品的服务器)  
5. 关于从浏览器内存拿缓存问题，这个不重要，重要再说  

### 深拷贝与浅拷贝
1. 浅拷贝=>是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。深拷贝=>是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。
2. 深拷贝方式: 1、Object.assign() 2、展开运算符... 3、JSON.parse(JSON.stringify()) 4、其他比如 函数库lodash的_.clone/或则递归手写

### promise 
1. promise 是构造函数，原型链上then,catch方法，用来解决回调地狱，根据单向不可逆状态的改变，在promise构造函数的参数回调函数处理执行异步操作，把异步操作的结果then和catch中处理
2. promise catch 优先 then的error回调，因为在then的success回调有错误，catch能继续执行，并把错误传到catch,不会终止运行，提高容错率，相当于try catch

### var，let,const 区别
1. 假设es5有块级作用域的概念，if和for的作用域相当于块级作用域， var 可以跨块级作用域访问(因为变量提升)，let ，const 不能跨块级作用作用域访问
2. 都不能跨函数作用域访问
3. var let 可以修改 const 不能修改
4. var let 可以不初始化  而const 必须初始化


### 请求响应时间长 
1. 前端只能给优化方案，请求分批请求再合并数据，给菊花图
2. 设置状态，一个查询状态请求，一个拿数据请求，然后去轮询/递归
3. 前端做一个缓存机制，取到前一次数据缓存，避免同一个下次请求
4. 再不行，怼后端去

### 函数作用域
声明在函数内部的变量和方法在(顶层外部与外部函数)是无法访问的，外部函数的变量和方法能被里层函数访问

### webp 图片格式优势


