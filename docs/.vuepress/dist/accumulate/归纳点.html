<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>归纳点(待细化分化) | pyidck’s blog</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/blog/favicon.png">
    <meta name="description" content="No pain, no gains!">
    <link rel="preload" href="/blog/assets/css/0.styles.5608eb1c.css" as="style"><link rel="preload" href="/blog/assets/js/app.b20ed355.js" as="script"><link rel="preload" href="/blog/assets/js/2.5595bcc7.js" as="script"><link rel="preload" href="/blog/assets/js/16.131ecad5.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.6f1625fb.js"><link rel="prefetch" href="/blog/assets/js/11.15c0259f.js"><link rel="prefetch" href="/blog/assets/js/12.ba1c6a1c.js"><link rel="prefetch" href="/blog/assets/js/13.43b1e9ac.js"><link rel="prefetch" href="/blog/assets/js/14.568ddf75.js"><link rel="prefetch" href="/blog/assets/js/15.9f70e73e.js"><link rel="prefetch" href="/blog/assets/js/17.5b3f6336.js"><link rel="prefetch" href="/blog/assets/js/18.c5aa4cec.js"><link rel="prefetch" href="/blog/assets/js/19.5bb6d762.js"><link rel="prefetch" href="/blog/assets/js/20.7c526414.js"><link rel="prefetch" href="/blog/assets/js/21.b610f6c4.js"><link rel="prefetch" href="/blog/assets/js/3.d4555585.js"><link rel="prefetch" href="/blog/assets/js/4.78934e54.js"><link rel="prefetch" href="/blog/assets/js/5.f1017ad7.js"><link rel="prefetch" href="/blog/assets/js/6.352c25b0.js"><link rel="prefetch" href="/blog/assets/js/7.01dd36e3.js"><link rel="prefetch" href="/blog/assets/js/8.7d429707.js"><link rel="prefetch" href="/blog/assets/js/9.1a71829d.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.5608eb1c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/favicon.png" alt="pyidck’s blog" class="logo"> <span class="site-name can-hide">pyidck’s blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/accumulate/" class="nav-link router-link-active">
  前端进阶积累
</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/cognize/" class="nav-link">
  认知
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/accumulate/" class="nav-link router-link-active">
  前端进阶积累
</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/cognize/" class="nav-link">
  认知
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>概述</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/accumulate/vue开发插件.html" class="sidebar-link">vue开发插件</a></li><li><a href="/blog/accumulate/高德地图.html" class="sidebar-link">高德地图</a></li><li><a href="/blog/accumulate/svg.html" class="sidebar-link">svg</a></li><li><a href="/blog/accumulate/axios的二次封装.html" class="sidebar-link">axios的二次封装</a></li><li><a href="/blog/accumulate/promise.html" class="sidebar-link">promise</a></li><li><a href="/blog/accumulate/async&amp;await.html" class="sidebar-link">async&amp;await</a></li><li><a href="/blog/accumulate/es5面向对象oop.html" class="sidebar-link">es5面向对象oop</a></li><li><a href="/blog/accumulate/归纳点.html" class="active sidebar-link">归纳点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#归纳点-待细化分化" class="sidebar-link">归纳点(待细化分化)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#props-与-ref-实例区别" class="sidebar-link">props 与 ref 实例区别</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#匿名插槽、具名插槽与作用域插槽-数据显示上区别-复合组件使用" class="sidebar-link">匿名插槽、具名插槽与作用域插槽 数据显示上区别(复合组件使用)</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#递归组件-name-作用" class="sidebar-link">递归组件 name 作用</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#provide-inject-传值应用场景" class="sidebar-link">provide/inject 传值应用场景</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#vue-extend-与-new-vue" class="sidebar-link">Vue.extend 与 new Vue</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#vue-插件-与-vue-组件区别" class="sidebar-link">Vue 插件 与 vue 组件区别</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#load-事件-与-hashchange-事件" class="sidebar-link">load 事件 与 hashchange 事件</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#bind" class="sidebar-link">bind</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#vue-插件作用" class="sidebar-link">vue 插件作用</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#es6-proxy" class="sidebar-link">es6 proxy</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#es5的object-defineproperty" class="sidebar-link">es5的Object.defineProperty</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#es5的object-defineproperty-vs-es6的proxy" class="sidebar-link">es5的Object.defineProperty() VS es6的Proxy</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#强缓存与协商缓存-缓存存的是静态资源" class="sidebar-link">强缓存与协商缓存(缓存存的是静态资源))</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#深拷贝与浅拷贝" class="sidebar-link">深拷贝与浅拷贝</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#promise" class="sidebar-link">promise</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#var-let-const-区别" class="sidebar-link">var，let,const 区别</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#请求响应时间长" class="sidebar-link">请求响应时间长</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#函数作用域" class="sidebar-link">函数作用域</a></li><li class="sidebar-sub-header"><a href="/blog/accumulate/归纳点.html#webp-图片格式优势" class="sidebar-link">webp 图片格式优势</a></li></ul></li></ul></li><li><a href="/blog/accumulate/刷题.html" class="sidebar-link">刷题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="归纳点-待细化分化"><a href="#归纳点-待细化分化" class="header-anchor">#</a> 归纳点(待细化分化)</h2> <h3 id="props-与-ref-实例区别"><a href="#props-与-ref-实例区别" class="header-anchor">#</a> props 与 ref 实例区别</h3> <ul><li>prop 着重于数据的传递，它并不能调用子组件里的属性(属性赋值给父组件)和方法。像创建文章组件时，自定义标题和内容这样的使用场景，最适合使用prop。</li> <li>$ref 着重于索引，主要用来调用子组件里的属性(属性赋值给父组件)和方法，其实并不擅长数据传递。而且ref用在dom元素的时候，能使到选择器的作用，这个功能比作为索引更常有用到。</li></ul> <h3 id="匿名插槽、具名插槽与作用域插槽-数据显示上区别-复合组件使用"><a href="#匿名插槽、具名插槽与作用域插槽-数据显示上区别-复合组件使用" class="header-anchor">#</a> 匿名插槽、具名插槽与作用域插槽 数据显示上区别(复合组件使用)</h3> <p>匿名插槽、具名插槽=&gt;数据由父组件控。 作用域插槽=&gt; 数据由子组件控制</p> <h3 id="递归组件-name-作用"><a href="#递归组件-name-作用" class="header-anchor">#</a> 递归组件 name 作用</h3> <p>自生调用自己 需要使用name</p> <h3 id="provide-inject-传值应用场景"><a href="#provide-inject-传值应用场景" class="header-anchor">#</a> provide/inject 传值应用场景</h3> <p>用于组件库封装</p> <h3 id="vue-extend-与-new-vue"><a href="#vue-extend-与-new-vue" class="header-anchor">#</a> Vue.extend 与 new Vue</h3> <p>vue.extend() 是new vue() 的一个子类。用法都一样，都是实例化一个对象，然后是挂载到到dom元素上。</p> <h3 id="vue-插件-与-vue-组件区别"><a href="#vue-插件-与-vue-组件区别" class="header-anchor">#</a> Vue 插件 与 vue 组件区别</h3> <p>Vue 插件 和 Vue组件 只是在 Vue.js 中包装的两个概念而已​，不管是插件还是组件，最终目的都是为了实现逻辑复用。它们的本质都是对代码逻辑的封装，只是封装方式不同而已。在必要时，组件也可以封装成插件，插件也可以改写成组件，就看实际哪种封装更方便使用了。</p> <h3 id="load-事件-与-hashchange-事件"><a href="#load-事件-与-hashchange-事件" class="header-anchor">#</a> load 事件 与 hashchange 事件</h3> <p>load=&gt;页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件。hashchange=&gt;当URL的片段标识符更改时，将触发hashchange事件 (跟在＃符号后面的URL部分，包括＃符号)</p> <h3 id="bind"><a href="#bind" class="header-anchor">#</a> bind</h3> <ul><li>call&amp;appy =&gt; call和apply改变了函数的this上下文后便执行该函数。bind =&gt; 则是返回改变了上下文后的一个函数，用于监听回调后执行。</li> <li>call与appy 只是传参数区别，es6存在扩展运算之后，基本随意使用，习惯用appy</li></ul> <h3 id="vue-插件作用"><a href="#vue-插件作用" class="header-anchor">#</a> vue 插件作用</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>MyPlugin<span class="token punctuation">.</span><span class="token function-variable function">install</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Vue<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 添加全局方法或 property</span>
  Vue<span class="token punctuation">.</span><span class="token function-variable function">myGlobalMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 逻辑...</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 2. 添加全局资源</span>
  Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-directive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">bind</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 逻辑...</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// 3. 注入组件选项</span>
  Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 逻辑...</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// 4. 添加实例方法</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$myMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">methodOptions</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 逻辑...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h3 id="es6-proxy"><a href="#es6-proxy" class="header-anchor">#</a> es6 proxy</h3> <p>用proxy实例对象去代理，拦截，操作源对象，让源对象不暴露</p> <h3 id="es5的object-defineproperty"><a href="#es5的object-defineproperty" class="header-anchor">#</a> es5的Object.defineProperty</h3> <ul><li><ol><li>为对象定义一个属性,或是修改已有属性的值，并设置该属性的描述符。该方法返回修改后的对象。</li></ol></li> <li><ol start="2"><li>getter(get:它是一个函数，访问该属性时会自动调用，函数的返回值即为该属性的value。默认为undefined。)与setter(set：它是一个函数，为该属性赋值时会自动调用，并且新值会被当做参数传入。), 为属性赋值的时候会自动执行一个函数，就能监控到数据的变化，从而实现mvvm的双向绑定。</li></ol></li> <li><ol start="3"><li>写一个公共模块，会往window上挂一些全局属性，并且你不希望别人在其他地方不小心覆盖这个属性，那就可以用defineProperty让该属性不可写、不可配置</li></ol></li></ul> <h3 id="es5的object-defineproperty-vs-es6的proxy"><a href="#es5的object-defineproperty-vs-es6的proxy" class="header-anchor">#</a> es5的Object.defineProperty() VS es6的Proxy</h3> <ol><li>Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</li> <li>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。</li> <li>Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li> <li>Proxy 兼容性差</li></ol> <h3 id="强缓存与协商缓存-缓存存的是静态资源"><a href="#强缓存与协商缓存-缓存存的是静态资源" class="header-anchor">#</a> 强缓存与协商缓存(缓存存的是静态资源))</h3> <ol><li><p>缓存的http原理(流程解释)：二次请求资源时，首先判断是否过期(新鲜度),<br>
1.1 没过期，从缓存中读取缓存(该缓存叫做强缓存)<br>
1.2 过期了，发送请求到服务器验证，<br>
1.2.1 资源对比，无修改过，读取缓存(该缓存叫做协商缓存)，更新缓存的属性信息<br>
1.2.2 资源对比，有修改过，<br>
1.2.3 请求成功拿到结果覆盖缓存
1.2.4 请求失败未获取结果，返回404，删除缓存</p></li> <li><p>不管是强缓存，还是协商缓存，都只有是get请求</p></li> <li><p>强缓存状态码---200 (from cache) 协商缓存状态码---304 (not modified)</p></li> <li><p>关于静态资源问题，一般改动不大的静态资源用cdn服务器上(如：bootsrap.min.js)，关于和业务相关的静态资源用业务服务器(即线上该产品的服务器)</p></li> <li><p>关于从浏览器内存拿缓存问题，这个不重要，重要再说</p></li></ol> <h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="header-anchor">#</a> 深拷贝与浅拷贝</h3> <ol><li>浅拷贝=&gt;是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。深拷贝=&gt;是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</li> <li>深拷贝方式: 1、Object.assign() 2、展开运算符... 3、JSON.parse(JSON.stringify()) 4、其他比如 函数库lodash的_.clone/或则递归手写</li></ol> <h3 id="promise"><a href="#promise" class="header-anchor">#</a> promise</h3> <ol><li>promise 是构造函数，原型链上then,catch方法，用来解决回调地狱，根据单向不可逆状态的改变，在promise构造函数的参数回调函数处理执行异步操作，把异步操作的结果then和catch中处理</li> <li>promise catch 优先 then的error回调，因为在then的success回调有错误，catch能继续执行，并把错误传到catch,不会终止运行，提高容错率，相当于try catch</li></ol> <h3 id="var-let-const-区别"><a href="#var-let-const-区别" class="header-anchor">#</a> var，let,const 区别</h3> <ol><li>假设es5有块级作用域的概念，if和for的作用域相当于块级作用域， var 可以跨块级作用域访问(因为变量提升)，let ，const 不能跨块级作用作用域访问</li> <li>都不能跨函数作用域访问</li> <li>var let 可以修改 const 不能修改</li> <li>var let 可以不初始化  而const 必须初始化</li></ol> <h3 id="请求响应时间长"><a href="#请求响应时间长" class="header-anchor">#</a> 请求响应时间长</h3> <ol><li>前端只能给优化方案，请求分批请求再合并数据，给菊花图</li> <li>设置状态，一个查询状态请求，一个拿数据请求，然后去轮询/递归</li> <li>前端做一个缓存机制，取到前一次数据缓存，避免同一个下次请求</li> <li>再不行，怼后端去</li></ol> <h3 id="函数作用域"><a href="#函数作用域" class="header-anchor">#</a> 函数作用域</h3> <p>声明在函数内部的变量和方法在(顶层外部与外部函数)是无法访问的，外部函数的变量和方法能被里层函数访问</p> <h3 id="webp-图片格式优势"><a href="#webp-图片格式优势" class="header-anchor">#</a> webp 图片格式优势</h3></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">5/30/2025, 3:01:30 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/accumulate/es5面向对象oop.html" class="prev">
        es5面向对象oop
      </a></span> <span class="next"><a href="/blog/accumulate/刷题.html">
        刷题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.b20ed355.js" defer></script><script src="/blog/assets/js/2.5595bcc7.js" defer></script><script src="/blog/assets/js/16.131ecad5.js" defer></script>
  </body>
</html>
